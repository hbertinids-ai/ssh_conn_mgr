import { useEffect, useRef, useState } from 'react';
import { Terminal as XTerm } from '@xterm/xterm';
import { FitAddon } from '@xterm/addon-fit';
import { WebLinksAddon } from '@xterm/addon-web-links';
import { useConnectionStore } from '../store/connectionStore';
import '@xterm/xterm/css/xterm.css';

interface TerminalInstance {
  term: XTerm;
  fitAddon: FitAddon;
  element: HTMLDivElement;
}

export function Terminal() {
  const terminalContainerRef = useRef<HTMLDivElement>(null);
  const terminalsRef = useRef<Map<string, TerminalInstance>>(new Map());
  const dataHandlerRef = useRef<((data: any) => void) | null>(null);
  const closeHandlerRef = useRef<((data: any) => void) | null>(null);
  const { sessions, activeSessionId, setSessionStatus, closeSession } = useConnectionStore();
  
  const activeSession = sessions.find((s) => s.id === activeSessionId);

  // Setup global SSH event handlers
  useEffect(() => {
    // Handle SSH data for all sessions
    const handleData = (data: any) => {
      const termInstance = terminalsRef.current.get(data.id);
      if (termInstance) {
        termInstance.term.write(data.data);
      }
    };

    // Handle SSH close for all sessions
    const handleClose = (data: any) => {
      const termInstance = terminalsRef.current.get(data.id);
      if (termInstance) {
        termInstance.term.writeln('\r\n\x1b[1;33mConnection closed\x1b[0m\r\n');
      }
      closeSession(data.id);
    };

    window.electron.ssh.onData(handleData);
    window.electron.ssh.onClose(handleClose);

    dataHandlerRef.current = handleData;
    closeHandlerRef.current = handleClose;

    return () => {
      // Cleanup will be handled when component unmounts
    };
  }, []);

  // Create terminal instances for each session
  useEffect(() => {
    if (!terminalContainerRef.current) return;

    // Create terminals for new sessions
    sessions.forEach((session) => {
      if (!terminalsRef.current.has(session.id)) {
        const terminalDiv = document.createElement('div');
        terminalDiv.className = 'h-full w-full';
        terminalDiv.style.display = session.id === activeSessionId ? 'block' : 'none';

        const term = new XTerm({
          cursorBlink: true,
          fontSize: 14,
          fontFamily: 'JetBrains Mono, Consolas, monospace',
          theme: {
            background: '#0f172a',
            foreground: '#e2e8f0',
            cursor: '#38bdf8',
            cursorAccent: '#0f172a',
            selectionBackground: '#334155',
            black: '#1e293b',
            red: '#ef4444',
            green: '#10b981',
            yellow: '#f59e0b',
            blue: '#3b82f6',
            magenta: '#8b5cf6',
            cyan: '#06b6d4',
            white: '#cbd5e1',
            brightBlack: '#475569',
            brightRed: '#f87171',
            brightGreen: '#34d399',
            brightYellow: '#fbbf24',
            brightBlue: '#60a5fa',
            brightMagenta: '#a78bfa',
            brightCyan: '#22d3ee',
            brightWhite: '#f1f5f9',
          },
        });

        const fitAddon = new FitAddon();
        const webLinksAddon = new WebLinksAddon();
        
        term.loadAddon(fitAddon);
        term.loadAddon(webLinksAddon);
        term.open(terminalDiv);
        fitAddon.fit();

        terminalContainerRef.current.appendChild(terminalDiv);
        terminalsRef.current.set(session.id, { term, fitAddon, element: terminalDiv });

    // Connect to SSH
    const connectSSH = async () => {
      try {
        const { connection } = activeSession;
        const tunnels = useConnectionStore.getState().tunnels;
        const tunnel = connection.tunnelId
          ? tunnels.find((t) => t.id === connection.tunnelId)
          : undefined;

        term.writeln(`\r\nConnecting to ${connection.username}@${connection.host}:${connection.port}...\r\n`);

        const config = {
          id: activeSession.id,
          host: connection.host.trim(),
          port: connection.port,
          username: connection.username.trim(),
          password: connection.password,
          privateKey: connection.privateKey,
          tunnel: tunnel
            ? {
                host: tunnel.host.trim(),
                port: tunnel.port,
                username: tunnel.username.trim(),
                password: tunnel.password,
              }
            : undefined,
        };

        console.log('Connecting with config:', { 
          host: config.host, 
          port: config.port, 
          username: config.username,
          hasTunnel: !!config.tunnel 
        });

        await window.electron.ssh.connect(config);
        setSessionStatus(activeSession.id, 'connected');
        term.writeln(`\r\n\x1b[1;32mConnected successfully!\x1b[0m\r\n`);
      } catch (error: any) {
        console.error('SSH Connection error:', error);
        setSessionStatus(activeSession.id, 'error', error.message);
        term.writeln(`\r\n\x1b[1;31mConnection Error: ${error.message || error}\x1b[0m\r\n`);
        term.writeln(`\r\nPlease check:\r\n`);
        term.writeln(`- Host address is correct (${activeSession.connection.host})\r\n`);
        term.writeln(`- Port is correct (${activeSession.connection.port})\r\n`);
        term.writeln(`- Credentials are valid\r\n`);
        term.writeln(`- Firewall allows the connection\r\n`);
      }
    };

    connectSSH();

    // Handle terminal input
    term.onData((data) => {
      window.electron.ssh.write(activeSession.id, data);
    });

    // Handle terminal resize
    const handleResize = () => {
      fitAddon.fit();
      window.electron.ssh.resize(activeSession.id, term.rows, term.cols);
    };

    window.addEventListener('resize', handleResize);

    // Handle SSH data
    window.electron.ssh.onData((data: any) => {
      if (data.id === activeSession.id) {
        term.write(data.data);
      }
    });

    // Handle SSH close
    window.electron.ssh.onClose((data: any) => {
      if (data.id === activeSession.id) {
        term.writeln('\r\n\x1b[1;33mConnection closed\x1b[0m\r\n');
        closeSession(activeSession.id);
      }
    });

    return () => {
      window.removeEventListener('resize', handleResize);
      window.electron.ssh.disconnect(activeSession.id);
      term.dispose();
    };
  }, [activeSession?.id]);

  if (!activeSession) {
    return null;
  }

  return (
    <div className="h-full bg-slate-900 p-4">
      <div ref={terminalRef} className="h-full" />
    </div>
  );
}
